#[allow(unused)]
fn main() {
    // 1. 生命周期很多情况下没法自动推导，导致能过编译的代码无法编译
    {
        #[derive(Debug)]
        struct Foo;

        impl Foo {
            // mutate_and_share函数传入的是一个可变的借用
            fn mutate_and_share(&mut self) -> &Self {
                &*self // 最终返回的是一个不可变的借用
            }
            fn share(&self) {}
        }

        let mut foo = Foo;
        let loan  = foo.mutate_and_share();
        foo.share();
        // println!("{:?}", loan); 这里会导致报错，说同时使用了可变和不可变的借用
        // 但是实际上不应该报错，因为实际上是两个不可变借用
        // 这是因为生命周期的要求，mutate_and_share检查生命周期的时候会要求传入的参数的生命周期大于等于返回参数的生命周期，因此，若返回值的生命周期在 main 函数有效，那 &mut self 的借用也是在 main 函数有效
        // 目前拿这种情况没什么办法，只能修改代码以符合要求
    }

    // 2. 无界生命周期
    {
        // unsafe的代码经常会凭空产生引用和生命周期，这种生命周期被称为无界的
        fn f<'a, T>(x: *const T) -> &'a T {
            unsafe {
                &*x
            }
        }
        // 参数 x 是一个裸指针，它并没有任何生命周期
        // 通过 unsafe 操作后，它被进行了解引用，变成了一个 Rust 的标准引用类型
        // 该类型必须要有生命周期，也就是 'a
        // 也就是说'a是凭空产生的，找不到来源
        // 实际应用中，要尽量避免这种无界生命周期
        // 最简单的避免无界生命周期的方式就是在函数声明中运用生命周期消除规则
        // 若一个输出生命周期被消除了，那么必定因为有一个输入生命周期与之对应
    }
}
